import type { DesignOptions, ProductType, TextStyle } from '../types';
import { TSHIRT_FONTS } from '../constants';

/**
 * Gets the dimensions of a base64 encoded image.
 */
const getImageDimensions = (base64: string): Promise<{ width: number; height: number }> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve({ width: img.width, height: img.height });
    img.onerror = () => reject(new Error('Failed to load image from base64 string.'));
    img.src = base64;
  });
};

/**
 * Calculates a contrasting color (black or white) for a given hex color.
 * Used for text outlines in the SVG.
 */
const getContrastColorForSvg = (hex: string): 'white' | 'black' => {
  let cleanHex = hex.startsWith('#') ? hex.slice(1) : hex;
  if (cleanHex.length === 3) {
    cleanHex = cleanHex.split('').map(char => char + char).join('');
  }
  if (cleanHex.length !== 6) return 'black'; // Default for invalid hex

  const r = parseInt(cleanHex.substring(0, 2), 16);
  const g = parseInt(cleanHex.substring(2, 4), 16);
  const b = parseInt(cleanHex.substring(4, 6), 16);
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  return brightness > 128 ? 'black' : 'white';
};

/**
 * Generates SVG text style attributes based on the selected style.
 */
const getTextStyleAttributes = (textStyle: TextStyle, color: string): string => {
  switch (textStyle) {
    case 'outline':
      const strokeColor = getContrastColorForSvg(color);
      return `fill="${color}" stroke="${strokeColor}" stroke-width="1" stroke-linejoin="round"`;
    case 'shadow':
      // Using a CSS filter for a simple drop shadow.
      return `fill="${color}" style="filter: drop-shadow(2px 2px 2px rgba(0,0,0,0.6));"`;
    case 'gradient':
      return `fill="url(#textGradient)"`;
    case 'pastel_rainbow':
      return `fill="url(#pastelRainbowGradient)"`;
    // Glow, 3D, and Metallic are complex visual effects generated by the AI.
    // For the vector SVG, we'll render them as clean text.
    case 'glow':
    case '3d':
    case 'metallic':
    case 'distressed':
    case 'fire':
    case 'comic':
    case 'glitch':
    case 'none':
    default:
      return `fill="${color}"`;
  }
};


/**
 * Generates a clean SVG representation of the design (logo + text).
 * This is suitable for vector use cases like laser engraving.
 */
export const generateDesignSvg = async (options: DesignOptions): Promise<string> => {
  const { logo, text, font, style, productType, textStyle, textColor, gradientStartColor, gradientEndColor } = options;
  if (!logo) {
    throw new Error("Logo is required to generate an SVG.");
  }

  const textProvided = text && text.trim().length > 0;
  const fontData = TSHIRT_FONTS.find(f => f.id === font);
  if (!fontData) {
    throw new Error(`Font ${font} not found.`);
  }

  // The font name for CSS (e.g., 'Bebas Neue'). The actual font files are now
  // preloaded in index.html to ensure they are available when the browser
  // renders the SVG for canvas conversion, avoiding security errors.
  const fontName = fontData.name;

  const { width: imgWidth, height: imgHeight } = await getImageDimensions(logo);
  const viewBoxWidth = 500;
  const viewBoxHeight = 500;

  // Scale image to fit within a bounding box
  const maxImgDim = style === 'split' ? 180 : 250;
  const scale = Math.min(maxImgDim / imgWidth, maxImgDim / imgHeight, 1);
  const scaledWidth = imgWidth * scale;
  const scaledHeight = imgHeight * scale;

  let imgX = (viewBoxWidth - scaledWidth) / 2;
  let imgY = style === 'split' 
    ? (viewBoxHeight - scaledHeight) / 2 // Center image for split style
    : (viewBoxHeight / 2) - scaledHeight * 0.8; // Position higher for other styles

  let textElements = '';
  let defsContent = '';

  if (textProvided) {
    if (textStyle === 'gradient') {
        defsContent += `
            <linearGradient id="textGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:${gradientStartColor};stop-opacity:1" />
                <stop offset="100%" style="stop-color:${gradientEndColor};stop-opacity:1" />
            </linearGradient>
        `;
    } else if (textStyle === 'pastel_rainbow') {
        defsContent += `
            <linearGradient id="pastelRainbowGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stop-color="#ffadad" />
                <stop offset="17%" stop-color="#ffd6a5" />
                <stop offset="34%" stop-color="#fdffb6" />
                <stop offset="51%" stop-color="#caffbf" />
                <stop offset="68%" stop-color="#9bf6ff" />
                <stop offset="85%" stop-color="#a0c4ff" />
                <stop offset="100%" stop-color="#bdb2ff" />
            </linearGradient>
        `;
    }

    const textStyleAttributes = getTextStyleAttributes(options.textStyle, textColor);
    const commonTextProps = `font-size="40px" ${textStyleAttributes} text-anchor="middle" dominant-baseline="middle"`;
    
    // Use the 'classic' style as a default for products that have text but no style selector
    const nonStyledProducts: ProductType[] = ['bag', 'phone_case', 'sticker', 'poster', 'wallet'];
    const effectiveStyle = nonStyledProducts.includes(productType) ? 'classic' : style;

    switch (effectiveStyle) {
      case 'classic': {
        const pathId = "arcPath";
        // An elliptical arc that looks good under the logo
        const arcY = imgY + scaledHeight + 40;
        const arcRadiusX = scaledWidth / 2;
        const arcRadiusY = scaledWidth / 2.2; // Adjusted for a semi-circular arc to prevent text clipping
        const pathD = `M ${imgX} ${arcY} A ${arcRadiusX} ${arcRadiusY} 0 0 1 ${imgX + scaledWidth} ${arcY}`;
        defsContent += `<path id="${pathId}" d="${pathD}" fill="none" />`;
        textElements = `
          <text ${textStyleAttributes} font-size="40px" text-anchor="middle">
            <textPath href="#${pathId}" startOffset="50%">${text}</textPath>
          </text>
        `;
        break;
      }
      case 'split': {
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const leftText = words.slice(0, midPoint).join(' ');
        const rightText = words.slice(midPoint).join(' ');
        const textY = viewBoxHeight / 2; // Center vertically
        const leftX = viewBoxWidth * 0.25;
        const rightX = viewBoxWidth * 0.75;
        textElements = `
          <text x="${leftX}" y="${textY}" ${commonTextProps}>${leftText}</text>
          <text x="${rightX}" y="${textY}" ${commonTextProps}>${rightText}</text>
        `;
        break;
      }
      case 'vintage_stamp': {
        const pathIdTop = "arcPathTop";
        const pathIdBottom = "arcPathBottom";
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const topText = words.slice(0, midPoint).join(' ');
        const bottomText = words.slice(midPoint).join(' ');
        
        const centerX = viewBoxWidth / 2;
        const centerY = viewBoxHeight / 2;
        const radius = scaledWidth / 2 + 20;

        const pathDTop = `M ${centerX - radius}, ${centerY} A ${radius},${radius} 0 0 1 ${centerX + radius},${centerY}`;
        const pathDBottom = `M ${centerX + radius}, ${centerY} A ${radius},${radius} 0 0 0 ${centerX - radius},${centerY}`;

        defsContent += `<path id="${pathIdTop}" d="${pathDTop}" fill="none" /><path id="${pathIdBottom}" d="${pathDBottom}" fill="none" />`;

        textElements = `
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdTop}" startOffset="50%">${topText}</textPath>
          </text>
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdBottom}" startOffset="50%">${bottomText}</textPath>
          </text>
        `;
        // For vintage stamp, center the logo
        imgY = (viewBoxHeight - scaledHeight) / 2;
        break;
      }
      case 'retro_wave': {
        const textY = imgY + scaledHeight + 45;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps} font-weight="bold">${text}</text>`;
        break;
      }
      case 'minimalist_line': {
        // Position logo on the left
        imgX = viewBoxWidth * 0.2;

        // Position text vertically on the right
        const textX = viewBoxWidth * 0.75;
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${textX}" y="${textY}" ${commonTextProps} transform="rotate(-90, ${textX}, ${textY})">${text}</text>`;
        break;
      }
      case 'grunge_overlay': {
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        // For grunge overlay, center the logo
        imgY = (viewBoxHeight - scaledHeight) / 2;
        break;
      }
      case 'stacked_text': {
        const words = text.split(/\s+/);
        const lineHeight = 45; // font-size + padding
        const startY = (imgY + scaledHeight + 25) + (lineHeight / 2); // Start below the image
        
        textElements = words.map((word, index) => 
          `<text x="${viewBoxWidth / 2}" y="${startY + (index * lineHeight)}" ${commonTextProps}>${word}</text>`
        ).join('');
        break;
      }
      case 'emblem': {
        // Treat 'emblem' like 'vintage_stamp' for SVG generation
        const pathIdTop = "arcPathTop";
        const pathIdBottom = "arcPathBottom";
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const topText = words.slice(0, midPoint).join(' ');
        const bottomText = words.slice(midPoint).join(' ');
        
        const centerX = viewBoxWidth / 2;
        const centerY = viewBoxHeight / 2;
        const radius = scaledWidth / 2 + 20;

        const pathDTop = `M ${centerX - radius}, ${centerY} A ${radius},${radius} 0 0 1 ${centerX + radius},${centerY}`;
        const pathDBottom = `M ${centerX + radius}, ${centerY} A ${radius},${radius} 0 0 0 ${centerX - radius},${centerY}`;

        defsContent += `<path id="${pathIdTop}" d="${pathDTop}" fill="none" /><path id="${pathIdBottom}" d="${pathDBottom}" fill="none" />`;

        textElements = `
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdTop}" startOffset="50%">${topText}</textPath>
          </text>
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdBottom}" startOffset="50%">${bottomText}</textPath>
          </text>
        `;
        imgY = (viewBoxHeight - scaledHeight) / 2;
        break;
      }
      case 'photo_text': {
        // Treat 'photo_text' like 'grunge_overlay' for SVG generation
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        imgY = (viewBoxHeight - scaledHeight) / 2;
        break;
      }
      // For gritty/slasher/cyberpunk styles, provide a clean, centered text version.
      case 'sketch':
      case 'slasher':
      case 'cyberpunk_glitch':
      case 'vintage_poster':
      case 'geometric_pattern':
      case 'hand_drawn_sketch':
      default: {
        const textY = imgY + scaledHeight + 45;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        break;
      }
    }
  }

  const defsElement = defsContent ? `<defs>${defsContent}</defs>` : '';

  // Assemble the final SVG string
  const svgContent = `<svg width="500" height="500" viewBox="0 0 ${viewBoxWidth} ${viewBoxHeight}" xmlns="http://www.w3.org/2000/svg">
  <style>
    text {
      font-family: '${fontName}', sans-serif;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
  ${defsElement}
  <image href="${logo}" x="${imgX}" y="${imgY}" width="${scaledWidth}" height="${scaledHeight}" />
  ${textElements}
</svg>`;

  // Return a formatted string
  return svgContent.trim().replace(/\n\s*/g, '');
};


/**
 * Generates a simplified, monochrome SVG of the text for laser engraving.
 * - Converts text to outlines (stroke only, no fill).
 * - The logo image is NOT included in this file. It must be handled separately.
 * - The text position is calculated relative to the uploaded logo's position.
 */
export const generateEngravingSvg = async (options: DesignOptions): Promise<string> => {
  const { logo, text, font, style } = options;
  if (!logo) {
    throw new Error("Logo is required to generate an SVG.");
  }

  const textProvided = text && text.trim().length > 0;
  const fontData = TSHIRT_FONTS.find(f => f.id === font);
  if (!fontData) {
    throw new Error(`Font ${font} not found.`);
  }

  const fontName = fontData.name;

  // We still need the logo dimensions to correctly position the text relative to where the logo would be.
  const { width: imgWidth, height: imgHeight } = await getImageDimensions(logo);
  const viewBoxWidth = 500;
  const viewBoxHeight = 500;

  const maxImgDim = style === 'split' ? 180 : 250;
  const scale = Math.min(maxImgDim / imgWidth, maxImgDim / imgHeight, 1);
  const scaledWidth = imgWidth * scale;
  const scaledHeight = imgHeight * scale;

  let imgX = (viewBoxWidth - scaledWidth) / 2;
  let imgY = style === 'split'
    ? (viewBoxHeight - scaledHeight) / 2
    : (viewBoxHeight / 2) - scaledHeight * 0.8;

  let textElements = '';
  if (textProvided) {
    // For engraving, we want a simple black outline.
    const textStyleAttributes = `fill="none" stroke="black" stroke-width="0.5"`;
    const commonTextProps = `font-size="40px" ${textStyleAttributes} text-anchor="middle" dominant-baseline="middle"`;

    switch (style) {
      case 'classic': {
        const pathId = "arcPathEngraving";
        const arcY = imgY + scaledHeight + 40;
        const arcRadiusX = scaledWidth / 2;
        const arcRadiusY = scaledWidth / 2.2; // Adjusted for a semi-circular arc to prevent text clipping
        const pathD = `M ${imgX} ${arcY} A ${arcRadiusX} ${arcRadiusY} 0 0 1 ${imgX + scaledWidth} ${arcY}`;
        textElements = `
          <defs>
            <path id="${pathId}" d="${pathD}" fill="none" />
          </defs>
          <text ${textStyleAttributes} font-size="40px" text-anchor="middle">
            <textPath href="#${pathId}" startOffset="50%">${text}</textPath>
          </text>
        `;
        break;
      }
      case 'split': {
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const leftText = words.slice(0, midPoint).join(' ');
        const rightText = words.slice(midPoint).join(' ');
        const textY = viewBoxHeight / 2;
        const leftX = viewBoxWidth * 0.25;
        const rightX = viewBoxWidth * 0.75;
        textElements = `
          <text x="${leftX}" y="${textY}" ${commonTextProps}>${leftText}</text>
          <text x="${rightX}" y="${textY}" ${commonTextProps}>${rightText}</text>
        `;
        break;
      }
       case 'vintage_stamp': {
        const pathIdTop = "arcPathEngravingTop";
        const pathIdBottom = "arcPathEngravingBottom";
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const topText = words.slice(0, midPoint).join(' ');
        const bottomText = words.slice(midPoint).join(' ');

        const centerX = viewBoxWidth / 2;
        const centerY = viewBoxHeight / 2;
        const radius = scaledWidth / 2 + 20;

        const pathDTop = `M ${centerX - radius}, ${centerY} A ${radius},${radius} 0 0 1 ${centerX + radius},${centerY}`;
        const pathDBottom = `M ${centerX + radius}, ${centerY} A ${radius},${radius} 0 0 0 ${centerX - radius},${centerY}`;

        textElements = `
          <defs>
            <path id="${pathIdTop}" d="${pathDTop}" fill="none" />
            <path id="${pathIdBottom}" d="${pathDBottom}" fill="none" />
          </defs>
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdTop}" startOffset="50%">${topText}</textPath>
          </text>
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdBottom}" startOffset="50%">${bottomText}</textPath>
          </text>
        `;
        break;
      }
      case 'retro_wave': {
        const textY = imgY + scaledHeight + 45;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps} font-weight="bold">${text}</text>`;
        break;
      }
      case 'minimalist_line': {
        // Text vertically on the right
        const textX = viewBoxWidth * 0.75;
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${textX}" y="${textY}" ${commonTextProps} transform="rotate(-90, ${textX}, ${textY})">${text}</text>`;
        break;
      }
      case 'grunge_overlay': {
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        break;
      }
      case 'stacked_text': {
        const words = text.split(/\s+/);
        const lineHeight = 45; // font-size + padding
        const startY = (imgY + scaledHeight + 25) + (lineHeight / 2); // Start below the image
        
        textElements = words.map((word, index) => 
          `<text x="${viewBoxWidth / 2}" y="${startY + (index * lineHeight)}" ${commonTextProps}>${word}</text>`
        ).join('');
        break;
      }
      case 'emblem': {
        // Treat 'emblem' like 'vintage_stamp' for SVG generation
        const pathIdTop = "arcPathEngravingTop";
        const pathIdBottom = "arcPathEngravingBottom";
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const topText = words.slice(0, midPoint).join(' ');
        const bottomText = words.slice(midPoint).join(' ');

        const centerX = viewBoxWidth / 2;
        const centerY = viewBoxHeight / 2;
        const radius = scaledWidth / 2 + 20;

        const pathDTop = `M ${centerX - radius}, ${centerY} A ${radius},${radius} 0 0 1 ${centerX + radius},${centerY}`;
        const pathDBottom = `M ${centerX + radius}, ${centerY} A ${radius},${radius} 0 0 0 ${centerX - radius},${centerY}`;

        textElements = `
          <defs>
            <path id="${pathIdTop}" d="${pathDTop}" fill="none" />
            <path id="${pathIdBottom}" d="${pathDBottom}" fill="none" />
          </defs>
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdTop}" startOffset="50%">${topText}</textPath>
          </text>
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdBottom}" startOffset="50%">${bottomText}</textPath>
          </text>
        `;
        break;
      }
      case 'photo_text': {
        // Treat 'photo_text' like 'grunge_overlay' for SVG generation
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        break;
      }
      case 'sketch':
      case 'slasher':
      case 'cyberpunk_glitch':
      case 'vintage_poster':
      case 'geometric_pattern':
      case 'hand_drawn_sketch':
      default: {
        const textY = imgY + scaledHeight + 45;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        break;
      }
    }
  }

  const svgContent = `<svg width="500" height="500" viewBox="0 0 ${viewBoxWidth} ${viewBoxHeight}" xmlns="http://www.w3.org/2000/svg">
  <!--
    This SVG file contains only the vector text for your design.
    The raster logo image has been excluded as it requires separate vector tracing for engraving.
    The text is positioned relative to where the logo would be.
  -->
  <style>
    text {
      font-family: '${fontName}', sans-serif;
    }
  </style>
  ${textElements}
</svg>`;

  return svgContent.trim().replace(/\n\s*/g, '');
};


/**
 * Generates a high-resolution, transparent PNG of the design from the SVG representation.
 * @param options The design options.
 * @param resolution The desired width and height of the output PNG.
 * @returns A promise that resolves with the base64 data URL of the PNG.
 */
export const generateDesignPng = async (options: DesignOptions, resolution: number = 2000): Promise<string> => {
  // Ensure all document fonts are loaded before attempting to render the SVG to canvas.
  // This prevents race conditions where the font isn't ready, causing rendering errors.
  await document.fonts.ready;
  
  const svgString = await generateDesignSvg(options);

  // Use a Base64 data URL for the SVG source. This is often more reliable
  // for canvas operations than a blob URL, especially with complex SVGs containing fonts.
  // The btoa(unescape(encodeURIComponent(...))) pattern is a common way to handle UTF-8 characters correctly.
  const svgDataUrl = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svgString)))}`;
  
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = resolution;
      canvas.height = resolution;
      const ctx = canvas.getContext('2d');

      if (!ctx) {
        reject(new Error('Could not get canvas context.'));
        return;
      }

      ctx.drawImage(img, 0, 0, resolution, resolution);
      
      const pngDataUrl = canvas.toDataURL('image/png');
      resolve(pngDataUrl);
    };

    img.onerror = () => {
      reject(new Error('Failed to load SVG into image element for PNG conversion.'));
    };

    img.src = svgDataUrl;
  });
};

/**
 * Generates a clean SVG representation of ONLY the text part of the design.
 * This is useful for downloading text as a separate asset.
 */
export const generateTextOnlySvg = async (options: DesignOptions): Promise<string> => {
  const { logo, text, font, style, productType, textStyle, textColor, gradientStartColor, gradientEndColor } = options;
  if (!logo) {
    throw new Error("Logo is required to calculate text layout for the SVG.");
  }
  
  const textProvided = text && text.trim().length > 0;
  if (!textProvided) {
    return `<svg width="500" height="500" viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg"></svg>`;
  }

  const fontData = TSHIRT_FONTS.find(f => f.id === font);
  if (!fontData) {
    throw new Error(`Font ${font} not found.`);
  }
  const fontName = fontData.name;

  const { width: imgWidth, height: imgHeight } = await getImageDimensions(logo);
  const viewBoxWidth = 500;
  const viewBoxHeight = 500;

  const maxImgDim = style === 'split' ? 180 : 250;
  const scale = Math.min(maxImgDim / imgWidth, maxImgDim / imgHeight, 1);
  const scaledWidth = imgWidth * scale;
  const scaledHeight = imgHeight * scale;

  let imgX = (viewBoxWidth - scaledWidth) / 2;
  let imgY = style === 'split' 
    ? (viewBoxHeight - scaledHeight) / 2
    : (viewBoxHeight / 2) - scaledHeight * 0.8;

  let textElements = '';
  let defsContent = '';

  if (textProvided) {
    if (textStyle === 'gradient') {
        defsContent += `
            <linearGradient id="textGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" style="stop-color:${gradientStartColor};stop-opacity:1" />
                <stop offset="100%" style="stop-color:${gradientEndColor};stop-opacity:1" />
            </linearGradient>
        `;
    } else if (textStyle === 'pastel_rainbow') {
        defsContent += `
            <linearGradient id="pastelRainbowGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" stop-color="#ffadad" />
                <stop offset="17%" stop-color="#ffd6a5" />
                <stop offset="34%" stop-color="#fdffb6" />
                <stop offset="51%" stop-color="#caffbf" />
                <stop offset="68%" stop-color="#9bf6ff" />
                <stop offset="85%" stop-color="#a0c4ff" />
                <stop offset="100%" stop-color="#bdb2ff" />
            </linearGradient>
        `;
    }

    const textStyleAttributes = getTextStyleAttributes(options.textStyle, textColor);
    const commonTextProps = `font-size="40px" ${textStyleAttributes} text-anchor="middle" dominant-baseline="middle"`;
    
    const nonStyledProducts: ProductType[] = ['bag', 'phone_case', 'sticker', 'poster', 'wallet'];
    const effectiveStyle = nonStyledProducts.includes(productType) ? 'classic' : style;

    switch (effectiveStyle) {
      case 'classic': {
        const pathId = "arcPath";
        const arcY = imgY + scaledHeight + 40;
        const arcRadiusX = scaledWidth / 2;
        const arcRadiusY = scaledWidth / 2.2;
        const pathD = `M ${imgX} ${arcY} A ${arcRadiusX} ${arcRadiusY} 0 0 1 ${imgX + scaledWidth} ${arcY}`;
        defsContent += `<path id="${pathId}" d="${pathD}" fill="none" />`;
        textElements = `
          <text ${textStyleAttributes} font-size="40px" text-anchor="middle">
            <textPath href="#${pathId}" startOffset="50%">${text}</textPath>
          </text>
        `;
        break;
      }
      case 'split': {
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const leftText = words.slice(0, midPoint).join(' ');
        const rightText = words.slice(midPoint).join(' ');
        const textY = viewBoxHeight / 2;
        const leftX = viewBoxWidth * 0.25;
        const rightX = viewBoxWidth * 0.75;
        textElements = `
          <text x="${leftX}" y="${textY}" ${commonTextProps}>${leftText}</text>
          <text x="${rightX}" y="${textY}" ${commonTextProps}>${rightText}</text>
        `;
        break;
      }
      case 'vintage_stamp': {
        const pathIdTop = "arcPathTop";
        const pathIdBottom = "arcPathBottom";
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const topText = words.slice(0, midPoint).join(' ');
        const bottomText = words.slice(midPoint).join(' ');
        
        const centerX = viewBoxWidth / 2;
        const centerY = viewBoxHeight / 2;
        const radius = scaledWidth / 2 + 20;

        const pathDTop = `M ${centerX - radius}, ${centerY} A ${radius},${radius} 0 0 1 ${centerX + radius},${centerY}`;
        const pathDBottom = `M ${centerX + radius}, ${centerY} A ${radius},${radius} 0 0 0 ${centerX - radius},${centerY}`;

        defsContent += `<path id="${pathIdTop}" d="${pathDTop}" fill="none" /><path id="${pathIdBottom}" d="${pathDBottom}" fill="none" />`;

        textElements = `
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdTop}" startOffset="50%">${topText}</textPath>
          </text>
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdBottom}" startOffset="50%">${bottomText}</textPath>
          </text>
        `;
        imgY = (viewBoxHeight - scaledHeight) / 2;
        break;
      }
      case 'retro_wave': {
        const textY = imgY + scaledHeight + 45;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps} font-weight="bold">${text}</text>`;
        break;
      }
      case 'minimalist_line': {
        imgX = viewBoxWidth * 0.2;
        const textX = viewBoxWidth * 0.75;
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${textX}" y="${textY}" ${commonTextProps} transform="rotate(-90, ${textX}, ${textY})">${text}</text>`;
        break;
      }
      case 'grunge_overlay': {
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        imgY = (viewBoxHeight - scaledHeight) / 2;
        break;
      }
      case 'stacked_text': {
        const words = text.split(/\s+/);
        const lineHeight = 45; // font-size + padding
        const startY = (imgY + scaledHeight + 25) + (lineHeight / 2); // Start below the image
        
        textElements = words.map((word, index) => 
          `<text x="${viewBoxWidth / 2}" y="${startY + (index * lineHeight)}" ${commonTextProps}>${word}</text>`
        ).join('');
        break;
      }
      case 'emblem': {
        // Treat 'emblem' like 'vintage_stamp' for SVG generation
        const pathIdTop = "arcPathTop";
        const pathIdBottom = "arcPathBottom";
        const words = text.split(/\s+/);
        const midPoint = Math.ceil(words.length / 2);
        const topText = words.slice(0, midPoint).join(' ');
        const bottomText = words.slice(midPoint).join(' ');
        
        const centerX = viewBoxWidth / 2;
        const centerY = viewBoxHeight / 2;
        const radius = scaledWidth / 2 + 20;

        const pathDTop = `M ${centerX - radius}, ${centerY} A ${radius},${radius} 0 0 1 ${centerX + radius},${centerY}`;
        const pathDBottom = `M ${centerX + radius}, ${centerY} A ${radius},${radius} 0 0 0 ${centerX - radius},${centerY}`;

        defsContent += `<path id="${pathIdTop}" d="${pathDTop}" fill="none" /><path id="${pathIdBottom}" d="${pathDBottom}" fill="none" />`;

        textElements = `
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdTop}" startOffset="50%">${topText}</textPath>
          </text>
          <text ${textStyleAttributes} font-size="30px" text-anchor="middle">
            <textPath href="#${pathIdBottom}" startOffset="50%">${bottomText}</textPath>
          </text>
        `;
        imgY = (viewBoxHeight - scaledHeight) / 2;
        break;
      }
      case 'photo_text': {
        // Treat 'photo_text' like 'grunge_overlay' for SVG generation
        const textY = viewBoxHeight / 2;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        imgY = (viewBoxHeight - scaledHeight) / 2;
        break;
      }
      case 'sketch':
      case 'slasher':
      case 'cyberpunk_glitch':
      case 'vintage_poster':
      case 'geometric_pattern':
      case 'hand_drawn_sketch':
      default: {
        const textY = imgY + scaledHeight + 45;
        textElements = `<text x="${viewBoxWidth / 2}" y="${textY}" ${commonTextProps}>${text}</text>`;
        break;
      }
    }
  }

  const defsElement = defsContent ? `<defs>${defsContent}</defs>` : '';

  const svgContent = `<svg width="500" height="500" viewBox="0 0 ${viewBoxWidth} ${viewBoxHeight}" xmlns="http://www.w3.org/2000/svg">
  <style>
    text {
      font-family: '${fontName}', sans-serif;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
  </style>
  ${defsElement}
  ${textElements}
</svg>`;

  return svgContent.trim().replace(/\n\s*/g, '');
};


/**
 * Generates a high-resolution, transparent PNG of ONLY the text part of the design from its SVG representation.
 * @param options The design options.
 * @param resolution The desired width and height of the output PNG.
 * @returns A promise that resolves with the base64 data URL of the PNG.
 */
export const generateTextOnlyPng = async (options: DesignOptions, resolution: number = 2000): Promise<string> => {
  await document.fonts.ready;
  
  const svgString = await generateTextOnlySvg(options);

  const svgDataUrl = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(svgString)))}`;
  
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = resolution;
      canvas.height = resolution;
      const ctx = canvas.getContext('2d');

      if (!ctx) {
        reject(new Error('Could not get canvas context.'));
        return;
      }

      ctx.drawImage(img, 0, 0, resolution, resolution);
      
      const pngDataUrl = canvas.toDataURL('image/png');
      resolve(pngDataUrl);
    };

    img.onerror = () => {
      reject(new Error('Failed to load SVG into image element for PNG conversion.'));
    };

    img.src = svgDataUrl;
  });
};